/* LICENSES */
const y=typeof self=="object"?self:globalThis,A=(c,f)=>{const r=(n,i)=>(c.set(i,n),n),a=n=>{if(c.has(n))return c.get(n);const[i,t]=f[n];switch(i){case 0:case-1:return r(t,n);case 1:{const s=r([],n);for(const e of t)s.push(a(e));return s}case 2:{const s=r({},n);for(const[e,I]of t)s[a(e)]=a(I);return s}case 3:return r(new Date(t),n);case 4:{const{source:s,flags:e}=t;return r(new RegExp(s,e),n)}case 5:{const s=r(new Map,n);for(const[e,I]of t)s.set(a(e),a(I));return s}case 6:{const s=r(new Set,n);for(const e of t)s.add(a(e));return s}case 7:{const{name:s,message:e}=t;return r(new y[s](e),n)}case 8:return r(BigInt(t),n);case"BigInt":return r(Object(BigInt(t)),n)}return r(new y[i](t),n)};return a},O=c=>A(new Map,c)(0),R="",{toString:S}={},{keys:h}=Object,p=c=>{const f=typeof c;if(f!=="object"||!c)return[0,f];const r=S.call(c).slice(8,-1);switch(r){case"Array":return[1,R];case"Object":return[2,R];case"Date":return[3,R];case"RegExp":return[4,R];case"Map":return[5,R];case"Set":return[6,R]}return r.includes("Array")?[1,r]:r.includes("Error")?[7,r]:[2,r]},T=([c,f])=>c===0&&(f==="function"||f==="symbol"),w=(c,f,r,a)=>{const n=(t,s)=>{const e=a.push(t)-1;return r.set(s,e),e},i=t=>{if(r.has(t))return r.get(t);let[s,e]=p(t);switch(s){case 0:{let o=t;switch(e){case"bigint":s=8,o=t.toString();break;case"function":case"symbol":if(c)throw new TypeError("unable to serialize "+e);o=null;break;case"undefined":return n([-1],t)}return n([s,o],t)}case 1:{if(e)return n([e,[...t]],t);const o=[],u=n([s,o],t);for(const E of t)o.push(i(E));return u}case 2:{if(e)switch(e){case"BigInt":return n([e,t.toString()],t);case"Boolean":case"Number":case"String":return n([e,t.valueOf()],t)}if(f&&"toJSON"in t)return i(t.toJSON());const o=[],u=n([s,o],t);for(const E of h(t))(c||!T(p(t[E])))&&o.push([i(E),i(t[E])]);return u}case 3:return n([s,t.toISOString()],t);case 4:{const{source:o,flags:u}=t;return n([s,{source:o,flags:u}],t)}case 5:{const o=[],u=n([s,o],t);for(const[E,g]of t)(c||!(T(p(E))||T(p(g))))&&o.push([i(E),i(g)]);return u}case 6:{const o=[],u=n([s,o],t);for(const E of t)(c||!T(p(E)))&&o.push(i(E));return u}}const{message:I}=t;return n([s,{name:e,message:I}],t)};return i},P=(c,{json:f,lossy:r}={})=>{const a=[];return w(!(f||r),!!f,new Map,a)(c),a};const{parse:b,stringify:M}=JSON,B={json:!0,lossy:!0},D=c=>O(b(c)),k=c=>M(P(c,B));export{D as parse,k as stringify};
//# sourceMappingURL=json-RdnQ9oUJ.js.map
