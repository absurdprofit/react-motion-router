{"version":3,"file":"json-RdnQ9oUJ.js","sources":["../../../node_modules/@ungap/structured-clone/esm/deserialize.js","../../../node_modules/@ungap/structured-clone/esm/serialize.js","../../../node_modules/@ungap/structured-clone/esm/json.js"],"sourcesContent":["import {\n  VOID, PRIMITIVE,\n  ARRAY, OBJECT,\n  DATE, REGEXP, MAP, SET,\n  ERROR, BIGINT\n} from './types.js';\n\nconst env = typeof self === 'object' ? self : globalThis;\n\nconst deserializer = ($, _) => {\n  const as = (out, index) => {\n    $.set(index, out);\n    return out;\n  };\n\n  const unpair = index => {\n    if ($.has(index))\n      return $.get(index);\n\n    const [type, value] = _[index];\n    switch (type) {\n      case PRIMITIVE:\n      case VOID:\n        return as(value, index);\n      case ARRAY: {\n        const arr = as([], index);\n        for (const index of value)\n          arr.push(unpair(index));\n        return arr;\n      }\n      case OBJECT: {\n        const object = as({}, index);\n        for (const [key, index] of value)\n          object[unpair(key)] = unpair(index);\n        return object;\n      }\n      case DATE:\n        return as(new Date(value), index);\n      case REGEXP: {\n        const {source, flags} = value;\n        return as(new RegExp(source, flags), index);\n      }\n      case MAP: {\n        const map = as(new Map, index);\n        for (const [key, index] of value)\n          map.set(unpair(key), unpair(index));\n        return map;\n      }\n      case SET: {\n        const set = as(new Set, index);\n        for (const index of value)\n          set.add(unpair(index));\n        return set;\n      }\n      case ERROR: {\n        const {name, message} = value;\n        return as(new env[name](message), index);\n      }\n      case BIGINT:\n        return as(BigInt(value), index);\n      case 'BigInt':\n        return as(Object(BigInt(value)), index);\n    }\n    return as(new env[type](value), index);\n  };\n\n  return unpair;\n};\n\n/**\n * @typedef {Array<string,any>} Record a type representation\n */\n\n/**\n * Returns a deserialized value from a serialized array of Records.\n * @param {Record[]} serialized a previously serialized value.\n * @returns {any}\n */\nexport const deserialize = serialized => deserializer(new Map, serialized)(0);\n","import {\n  VOID, PRIMITIVE,\n  ARRAY, OBJECT,\n  DATE, REGEXP, MAP, SET,\n  ERROR, BIGINT\n} from './types.js';\n\nconst EMPTY = '';\n\nconst {toString} = {};\nconst {keys} = Object;\n\nconst typeOf = value => {\n  const type = typeof value;\n  if (type !== 'object' || !value)\n    return [PRIMITIVE, type];\n\n  const asString = toString.call(value).slice(8, -1);\n  switch (asString) {\n    case 'Array':\n      return [ARRAY, EMPTY];\n    case 'Object':\n      return [OBJECT, EMPTY];\n    case 'Date':\n      return [DATE, EMPTY];\n    case 'RegExp':\n      return [REGEXP, EMPTY];\n    case 'Map':\n      return [MAP, EMPTY];\n    case 'Set':\n      return [SET, EMPTY];\n  }\n\n  if (asString.includes('Array'))\n    return [ARRAY, asString];\n\n  if (asString.includes('Error'))\n    return [ERROR, asString];\n\n  return [OBJECT, asString];\n};\n\nconst shouldSkip = ([TYPE, type]) => (\n  TYPE === PRIMITIVE &&\n  (type === 'function' || type === 'symbol')\n);\n\nconst serializer = (strict, json, $, _) => {\n\n  const as = (out, value) => {\n    const index = _.push(out) - 1;\n    $.set(value, index);\n    return index;\n  };\n\n  const pair = value => {\n    if ($.has(value))\n      return $.get(value);\n\n    let [TYPE, type] = typeOf(value);\n    switch (TYPE) {\n      case PRIMITIVE: {\n        let entry = value;\n        switch (type) {\n          case 'bigint':\n            TYPE = BIGINT;\n            entry = value.toString();\n            break;\n          case 'function':\n          case 'symbol':\n            if (strict)\n              throw new TypeError('unable to serialize ' + type);\n            entry = null;\n            break;\n          case 'undefined':\n            return as([VOID], value);\n        }\n        return as([TYPE, entry], value);\n      }\n      case ARRAY: {\n        if (type)\n          return as([type, [...value]], value);\n  \n        const arr = [];\n        const index = as([TYPE, arr], value);\n        for (const entry of value)\n          arr.push(pair(entry));\n        return index;\n      }\n      case OBJECT: {\n        if (type) {\n          switch (type) {\n            case 'BigInt':\n              return as([type, value.toString()], value);\n            case 'Boolean':\n            case 'Number':\n            case 'String':\n              return as([type, value.valueOf()], value);\n          }\n        }\n\n        if (json && ('toJSON' in value))\n          return pair(value.toJSON());\n\n        const entries = [];\n        const index = as([TYPE, entries], value);\n        for (const key of keys(value)) {\n          if (strict || !shouldSkip(typeOf(value[key])))\n            entries.push([pair(key), pair(value[key])]);\n        }\n        return index;\n      }\n      case DATE:\n        return as([TYPE, value.toISOString()], value);\n      case REGEXP: {\n        const {source, flags} = value;\n        return as([TYPE, {source, flags}], value);\n      }\n      case MAP: {\n        const entries = [];\n        const index = as([TYPE, entries], value);\n        for (const [key, entry] of value) {\n          if (strict || !(shouldSkip(typeOf(key)) || shouldSkip(typeOf(entry))))\n            entries.push([pair(key), pair(entry)]);\n        }\n        return index;\n      }\n      case SET: {\n        const entries = [];\n        const index = as([TYPE, entries], value);\n        for (const entry of value) {\n          if (strict || !shouldSkip(typeOf(entry)))\n            entries.push(pair(entry));\n        }\n        return index;\n      }\n    }\n\n    const {message} = value;\n    return as([TYPE, {name: type, message}], value);\n  };\n\n  return pair;\n};\n\n/**\n * @typedef {Array<string,any>} Record a type representation\n */\n\n/**\n * Returns an array of serialized Records.\n * @param {any} value a serializable value.\n * @param {{json?: boolean, lossy?: boolean}?} options an object with a `lossy` or `json` property that,\n *  if `true`, will not throw errors on incompatible types, and behave more\n *  like JSON stringify would behave. Symbol and Function will be discarded.\n * @returns {Record[]}\n */\n export const serialize = (value, {json, lossy} = {}) => {\n  const _ = [];\n  return serializer(!(json || lossy), !!json, new Map, _)(value), _;\n};\n","/*! (c) Andrea Giammarchi - ISC */\n\nimport {deserialize} from './deserialize.js';\nimport {serialize} from './serialize.js';\n\nconst {parse: $parse, stringify: $stringify} = JSON;\nconst options = {json: true, lossy: true};\n\n/**\n * Revive a previously stringified structured clone.\n * @param {string} str previously stringified data as string.\n * @returns {any} whatever was previously stringified as clone.\n */\nexport const parse = str => deserialize($parse(str));\n\n/**\n * Represent a structured clone value as string.\n * @param {any} any some clone-able value to stringify.\n * @returns {string} the value stringified.\n */\nexport const stringify = any => $stringify(serialize(any, options));\n"],"names":["env","deserializer","$","_","as","out","index","unpair","type","value","arr","object","key","source","flags","map","set","name","message","deserialize","serialized","EMPTY","toString","keys","typeOf","asString","shouldSkip","TYPE","serializer","strict","json","pair","entry","entries","serialize","lossy","$parse","$stringify","options","parse","str","stringify","any"],"mappings":"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","x_google_ignoreList":[0,1,2]}